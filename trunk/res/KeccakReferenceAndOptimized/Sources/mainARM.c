/*
Algorithm Name: Keccak
Authors: Guido Bertoni, Joan Daemen, MichaÃ«l Peeters and Gilles Van Assche
Implementation by Ronny Van Keer, STMicroelectronics

This code, originally by Ronny Van Keer, is hereby put in the public domain. 
It is given as is, without any guarantee.

For more information, feedback or questions, please refer to our website:
http://keccak.noekeon.org/
*/

#include "KeccakF-1600-interface.h"
#include "KeccakNISTInterface.h"
#include "string.h"

typedef unsigned char UINT8;
typedef unsigned short UINT16;
typedef unsigned int UINT32;

int main()
{
    UINT32 x = 0;
    int i;
	{
	    UINT32 state[50];
	    const UINT32 imageOfAllZero[50] = {
	        0xD33D89FB, 0xC4B60CAD, 0x2FAD58B0, 0x88AE581B, 0xF4262C1A, 
	        0x8A53D3EF, 0x77B4B09B, 0xE0147822, 0x10A38DCF, 0xB6305181, 
	        0xF723F2BE, 0xF9C67B78, 0x4EB02ABA, 0x8FCCC118, 0x2DC2E52E, 
	        0xA3B29275, 0x342F5536, 0xE4DD320A, 0x45C7C3EA, 0x493D8BE4, 
	        0x9C1717E7, 0xF3E75194, 0x12A23D11, 0xEDD52441, 0x13E6DBFF, 
	        0x8C61BB03, 0x945B1B82, 0x1E4A11A5, 0x1C3453E7, 0x0D730C1B, 
	        0x3B9C1D29, 0x0C534AF4, 0xA6EC29CC, 0x4FFDAA4D, 0x96C7DAA5, 
	        0x45487850, 0x4ECFBC29, 0xE630383B, 0x26806B48, 0xA7EB2B5A,
	        0x62D02426, 0x8265F750, 0x49D20B1A, 0x20E4D82C, 0x6F72B2B8, 
	        0x1C45D049, 0xFEA9F415, 0x4D0E74C7, 0x8DFDEA09, 0xFCF72ED2 };

		// Test 1 (all-zero state through Keccak-f[1600])
	    memset(state, 0, 50*sizeof(UINT32));
		KeccakPermutation((unsigned char*)state);
	    for(i=0; i<50; i++)
	        if (state[i] != imageOfAllZero[i])
	            for( ; ; ) {
					//	Kaccek (aka other algo)
	                x++;
	            }
		// For benchmarking
		{
			#ifdef ProvideFast1024
			KeccakAbsorb1024bits((unsigned char*)state, (unsigned char*)imageOfAllZero);
			#else
			KeccakAbsorb((unsigned char*)state, (unsigned char*)imageOfAllZero, 16);
			#endif
		}
	}
	{
		hashState state;
		const UINT8 Msg29[4] = { 0x53, 0x58, 0x7B, 0xC8 };
		const UINT8 Msg29_out[160] = {
			0xDE, 0xEB, 0xFB, 0x5F, 0xBC, 0x67, 0x14, 0x3A, 0x70, 0xF5, 0xEE, 0x51, 0x8F, 0x3C, 0xE2, 0x0A, 
			0x70, 0x2A, 0x3C, 0x25, 0x0C, 0x22, 0xD9, 0x39, 0xD7, 0xEE, 0xF5, 0x98, 0xA3, 0x9C, 0xA5, 0xC5, 
			0x37, 0x41, 0xB6, 0xF5, 0x7B, 0x58, 0x40, 0xAD, 0xD2, 0x8E, 0xF6, 0x14, 0x0A, 0xAD, 0x9D, 0x4C, 
			0x2B, 0x8E, 0xCC, 0x6A, 0x89, 0xFC, 0x5E, 0xFE, 0x73, 0x1F, 0x5E, 0x69, 0x7B, 0x83, 0xB8, 0x1C, 
			0x27, 0xED, 0xE0, 0xD2, 0x26, 0xBB, 0x30, 0xDE, 0x0A, 0x93, 0xF5, 0xCE, 0xDB, 0xC1, 0x6E, 0x32, 
			0xBA, 0x9D, 0x6B, 0x10, 0x48, 0x8A, 0x5A, 0x0E, 0x55, 0x5C, 0xB2, 0x96, 0x9F, 0x51, 0xE5, 0x8D, 
			0x46, 0xF0, 0x03, 0xF5, 0x0F, 0x9D, 0x84, 0x5A, 0xAF, 0x43, 0x07, 0x66, 0x76, 0x23, 0x82, 0xAD, 
			0xFD, 0x9B, 0x4C, 0xF0, 0x59, 0x16, 0xDF, 0xD6, 0x5C, 0x8A, 0x8C, 0xFC, 0xDE, 0xC5, 0xD0, 0x45, 
			0x34, 0x07, 0x38, 0x7D, 0xBC, 0xF3, 0xA7, 0x44, 0x26, 0x8E, 0x85, 0xB3, 0x5B, 0x50, 0x0E, 0xDD, 
			0x1E, 0xD5, 0x09, 0x01, 0x55, 0xA6, 0x35, 0xBF, 0xA4, 0x6A, 0xC2, 0x4D, 0xA7, 0x98, 0xE8, 0x24 };
		UINT8 output[160];

		// Test 2 (message of length 29 from ShortMsgKAT_0.txt)
		Init(&state, 0);
		Update(&state, Msg29, 29);
		Final(&state, 0);
		Squeeze(&state, output, 160*8);
	    for(i=0; i<160; i++)
	        if (output[i] != Msg29_out[i])
	            for( ; ; ) {
					//	Kaccek (aka other algo)
	                x++;
	            }
	}

	for ( ; ; ) ;
}
